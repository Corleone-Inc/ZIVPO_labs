# ZIVPO-Lab5-
# Лабораторная работа 5
**Работу выполнили Дзюба Д.В и Алиев С.Г**
## SAST
### Анализ инструментом Fortify
Результаты сканирования:
<img width="2556" height="1386" alt="Screenshot 2025-12-14 214809" src="https://github.com/user-attachments/assets/48f0e6c6-a162-4347-896e-63a578087765" />
Отчет по уязвимости:
Тип уязвимости: Хардкодинг (жёсткая привязка) криптографического ключа
Instance ID: 51DD573C9D1FF439DECD37FE4F612F52  
#### 1. Суть уязвимости
В коде приложения используется жёстко заданный (hardcoded) ключ шифрования, то есть значение ключа напрямую указано в исходном коде как строковая или байтовая константа.
```python
from Crypto.Ciphers import AES
encryption_key = b'_hardcoded__key_'
cipher = AES.new(encryption_key, AES.MODE_CFB, iv)
msg = iv + cipher.encrypt(b'Attack at dawn')
```
#### 2. Потенциальная опасность
- Раскрытие ключа: Любой, у кого есть доступ к исходному коду (разработчики, стажёры, злоумышленник при утечке кода), сразу получает доступ к ключу шифрования.
- Затруднённое исправление: После развёртывания приложения в продакшене изменение ключа возможно только через обновление кода и повторное развёртывание, что может быть технически сложно и дорого.
- Риск компрометации данных: Если ключ становится известен злоумышленнику, он может:
	- Расшифровать все ранее зашифрованные данные.
	- Подделать или подменить зашифрованные сообщения.
- Нарушение принципов безопасного хранения секретов: Ключи шифрования должны храниться вне исходного кода, в защищённых хранилищах (например, HashiCorp Vault, AWS Secrets Manager, переменные окружения с ограничением доступа и т.д.).
#### 3. Оценка риска (по данным Forify)
<table>
    <tr>
        <th>Параметр</th>
        <th>Значение</th>
    </tr>
    <tr>
        <td>Impact (Последствия)</td>
        <td>3.0/5.0</td>
    </tr>
    <tr>
        <td>Likelihood (Вероятность эксплуатации)</td>
        <td>2.4/5.0</td>
    </tr>
    <tr>
        <td>Severity (Общая серьезность)</td>
        <td>4.0/5.0</td>
    </tr>
    <tr>
        <td>Confidence (Уверенность в обнаружении)</td>
        <td>5.0/5.0</td>
    </tr>
</table>
Согласно Fortify, эта критическая уязвимость может привести к серьезным последствиям при компрометации.

#### 4. Рекомендации по устранению
- Удалить хардкодированный ключ из исходного кода.
- Хранить ключи шифрования в безопасных внешних источниках, например:
	- Переменные окружения (с ограничением доступа на уровне ОС/контейнера).
	- Специализированные хранилища секретов: AWS Secrets Manager, Azure Key Vault, HashiCorp Vault.
	- Зашифрованные конфигурационные файлы с контролем доступа.
- Ограничить доступ к хранилищу ключей только тем компонентам системы, которые действительно должны их использовать.
- Реализовать механизм ротации ключей, чтобы в случае компрометации можно было легко заменить ключ без изменения кода.
- Провести аудит всего кода на предмет других хардкодированных секретов (паролей, токенов, API-ключей и т.д.).
### Анализ инструментом Bandit
Сводка по выявленным уязвимостям:
<table>
    <tr>
        <th>Уровень серьезности</th>
        <th>Количество</th>
    </tr>
    <tr>
        <td>High</td>
        <td>2</td>
    </tr>
    <tr>
        <td>Medium</td>
        <td>4</td>
    </tr>
    <tr>
        <td>Low</td>
        <td>3</td>
    </tr>
</table>

1. CWE-502: Deserialization of Untrusted Data
- Bandit ID: `B403` (импорт `pickle`) + `B301` (вызов `pickle.loads`)  
- Строки: 7, 166  
- Серьёзность: Low (B403), Medium (B301)  
- Уверенность: High
Модуль `pickle` в Python небезопасен при десериализации данных из недоверенного источника. Злоумышленник может создать специально сформированный pickle-объект, при десериализации которого будет выполнено произвольное Python-код.
Пример из кода:
```python
data = pickle.loads(bytes.fromhex(user_data))
```
Здесь `user_data` поступает от пользователя и никак не проверяется. Таким образом, появляется риск выполнения произвольного кода на сервере и полной компрометации приложения. Во избежании таких проблем не нужно использовать `pickle` для обмена с внешними системами и пользователями, также следуюет использовать безопасные форматы: JSON, XML и т.д. Если же `pickle` критически необходим можно применить подписи или шифрование + аутентификацию данных, и никогда не десериализировать без доверенного источника.
2. CWE-78: OS Command Injection
- Bandit ID: B404 (импорт `subprocess`) + B602 (использование `shell=True`)  
- Строки: 8, 185  
- Серьёзность: Low (B404), High (B602)  
- Уверенность: High
Код использует `subprocess.check_output(..., shell=True)` с непроверенными пользовательскими данными, что открывает путь для инъекции команд ОС.
Пример из кода:
```python
result = subprocess.check_output(f"ping -c 1 {host}", shell=True, text=True)
```
Если host содержит, например: `8.8.8.8; rm -rf /`, то команда `rm -rf /` будет выполнена.
Риски: удаление файлов, запуск вредоносных процессов, кража данных, вероятность полного захвата сервера.
Рекомендации: 
- Никогда не использовать shell=True с данными от пользователя  
- Передавать аргументы в виде списка
- Валидировать host как доменное имя или IP-адрес (регулярные выражения, allowlist)
- Ограничить права процесса (principle of least privilege)
3. CWE-259: Hardcoded Password / Secret
- Bandit ID: B105  
- Строка: 12  
- Серьёзность: Low  
- Уверенность: Medium
Секретный ключ Flask задан как строковая константа: `app.secret_key = 'supersecretkey'`
Риск: любой, у кого есть доступ к коду (включая репозиторий), знает ключ сессий, возможна подделка сессий, аутентификационных токенов и т.д.
Рекомендации:
- Загружать ключ из переменной окружения или защищённого хранилища секретов
- Использовать криптографически стойкие ключи (32+ байта случайных данных)
4. CWE-89: SQL Injection
- Bandit ID: B608  
- Строка: 43  
- Серьёзность: Medium  
- Уверенность: Low
SQL-запрос формируется через конкатенацию строк с пользовательским вводом:
```python
query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
```
Риски:
- Обход аутентификации (например, ввод admin'--)  
- Чтение/изменение/удаление любых данных в БД  
- В некоторых СУБД — выполнение ОС-команд (например, xp_cmdshell в MS SQL)
Рекомендации:
- Использовать параметризованные запросы
- Никогда не сравнивать пароли напрямую в SQL — хранить хэши (bcrypt, Argon2) и проверять их в коде
5. CWE-400: Uncontrolled Resource Consumption (Missing Timeout)
- Bandit ID: B113  
- Строка: 206  
- Серьёзность: Medium  
- Уверенность: Low
Вызов `requests.get(url)` без таймаута:
```python
response = requests.get(url)
```
Риски:
- Возможность DoS-атаки: внешний сервер может «зависнуть» и удерживать соединение  
- Исчерпание пула соединений, потоков или памяти
Рекомендации: всегда указывать таймаут
6. CWE-94: Code Injection via Debug Mode (Flask)
- Bandit ID: B201  
- Строка: 256  
- Серьёзность: High  
- Уверенность: Medium
Приложение запускается с debug=True:
```python
app.run(debug=True, host='0.0.0.0', port=5000)
```
Риски:
- Werkzeug debugger позволяет выполнять произвольный Python-код через веб-интерфейс  
- При публичной доступности (особенно на 0.0.0.0) — мгновенный компромет
Рекомендации:
- Всегда отключать debug=True в продакшене  
- Использовать переменные окружения
7. CWE-605: Binding to All Interfaces
- Bandit ID: B104  
- Строка: 256  
- Серьёзность: Medium  
- Уверенность: Medium
Сервер слушает на всех интерфейсах: `host='0.0.0.0'`
Риски:
- Приложение доступно извне, даже если предназначено только для локального использования  
- Увеличивает поверхность атаки
Рекомендации:
- В разработке: host='127.0.0.1'  
- В продакшене: использовать обратный прокси (Nginx), а не прямой запуск Flask на публичном IP  
- Контролировать доступ через firewall
В заключении, можно составить следующий рекомендуемый порядок действий:
1. Убрать debug=True и host='0.0.0.0'
2. Заменить subprocess с shell=True на безопасный вызов без shell
3. Устранить использование pickle для пользовательских данных
4. Перейти на параметризованные SQL-запросы
5. Внедрить безопасное управление секретами и таймаутами



## DAST
Целевое приложение: `vulnerable_app.py` (Flask-приложение)

## Шаги развертывания:

**Создание виртуального окружения**

`python3 -m venv venv`

**Активация (Linux/Mac)**

`source venv/bin/activate`

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/Снимок_экрана_2025-12-14_200911.jpg" width="800" height="600">




**Установка зависимостей**

pip install Flask==2.3.3 requests==2.31.0

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/Снимок_экрана_2025-12-14_201118.jpg" width="800" height="600">

**Запуск приложения**

python vulnerable_app.py

Результат: Приложение успешно запущено и доступно по адресу http://localhost:5000.

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/Снимок_экрана_2025-12-14_201825.jpg" width="800" height="600">


## Сканирование с использованием OWASP ZAP

Сначала запустили ZAPROXY из меню Kali Linux и создали новый контекст с целевым URL: http://localhost:5000, затем запустили автоматическое сканирование (сначала Spider + Actie scan)

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/Снимок_экрана_2025-12-14_215329.jpg" width="800" height="600">

Затем выполнили фаззинг через интерфейс ZAP. Для этого выбрали запрос GET:search(q) в History. Выбрали параметр q и добавили payloads из файла

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/Снимок_экрана_2025-12-14_215805.jpg" width="800" height="600">
<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/add_fuzz_file.jpg" width="800" height="600">

По итогу вот что получилось после полного сканирования инструментом Zaproxy

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/Снимок_экрана_2025-12-14_223950.jpg" width="800" height="600">

## Сканирование с использованием Nikto

Для дополнительного анализа используем Nikto. 
```bash

sudo apt update
sudo apt install nikto
nikto -h http://localhost:5000 -0 nikto_otchet.html -Format html
```
В итоге получем вот такой отчет
<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/nitko_pro1.jpg" width="800" height="600">
<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/nikto_pro2.jpg" width="800" height="600">

## ТРИАЖ УЯЗВИМОСТЕЙ

В рамках выполнения лабораторной работы был развернут уязвимый веб-приложение OWASP Juice Shop, доступное по адресу:

`http://localhost:3000`

Для динамического анализа и выявления уязвимостей использовался инструмент OWASP ZAP (Zed Attack Proxy)
Сканирование включало в себя:

* Spider-обход приложения;

* Активное сканирование выявленных точек входа;

* Фаззинг параметров HTTP-запросов.

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/OWASP_triage.jpg" width="800" height="600">

По результатам анализа был сформирован отчёт OWASP ZAP, содержащий 12 различных типов уязвимостей с уровнями риска от Informational до High.


**Выбор уязвимостей для триажа**

Для проведения триажа были отобраны следующие уязвимости из отчёта OWASP ZAP:

* SQL Injection (SQLite) — уровень риска High

* Content Security Policy (CSP) Header Not Set — уровень риска Medium

* Session ID in URL Rewrite — уровень риска Medium

* Cross-Domain Misconfiguration — уровень риска Medium

* Timestamp Disclosure (Unix) — уровень риска Low


## Классификация уязвимостей (этап триажа)



### 1. SQL Injection – SQLite

**Тип:**  Истинная уязвимость
**Критичность:** High (Critical)
**CWE:** CWE-89
**OWASP Top 10:** A03:2021 – Injection

**CVSS 3.1:**

```
AV:N / AC:L / PR:N / UI:N / S:U / C:H / I:H / A:H
```

**CVSS Score:** 9.8

**Описание:**
Уязвимость обнаружена в параметре `q` эндпоинта `/rest/products/search`. При передаче специально сформированного значения сервер возвращает сообщение об ошибке SQLite, что подтверждает возможность SQL-инъекции.

**Сетевая доступность:**
Доступна без аутентификации по HTTP.

**Ценность актива:**
База данных приложения (товары, заказы, пользовательские данные).

**Сложность эксплуатации:**
Низкая. Не требует аутентификации и специальных условий.

**Потенциальный ущерб для бизнеса:**

* утечка и модификация данных;
* компрометация пользователей;
* нарушение целостности приложения;
* репутационные и регуляторные риски.

**Приоритет устранения:**  Наивысший

**Краткосрочные меры:**

* фильтрация и валидация входных данных;
* временное ограничение функционала поиска.

**Долгосрочные меры:**

* использование параметризованных запросов;
* внедрение ORM;
* повторное тестирование после исправления.


### 2. Content Security Policy (CSP) Header Not Set

**Тип:**  Истинная уязвимость
**Критичность:** Medium
**CWE:** CWE-693
**OWASP Top 10:** A05:2021 – Security Misconfiguration

**CVSS 3.1:**

```
AV:N / AC:L / PR:N / UI:R / S:U / C:L / I:L / A:N
```

**CVSS Score:** 5.4

**Описание:**
В HTTP-ответах отсутствует заголовок `Content-Security-Policy`, что снижает защиту от XSS и внедрения вредоносных скриптов.

**Сетевая доступность:**
Доступна всем пользователям.

**Ценность актива:**
Клиентская часть приложения и данные пользователей.

**Сложность эксплуатации:**
Средняя. Обычно требует наличия дополнительной XSS-уязвимости.

**Потенциальный ущерб:**

* кража cookies;
* подмена контента;
* выполнение вредоносного JavaScript.

**Приоритет устранения:**  Высокий

**Краткосрочные (компенсирующие) меры:**

* добавить базовый заголовок Content-Security-Policy с ограничением script-src 'self';

* временно запретить загрузку скриптов с внешних доменов.

**Долгосрочные (устраняющие) меры:**

* разработать строгую CSP-политику под архитектуру приложения;

* минимизировать использование inline-скриптов;

* регулярно проверять CSP на совместимость и безопасность.


### 3. Session ID in URL Rewrite

**Тип:**  Истинная уязвимость
**Критичность:** Medium

**CVSS 3.1:**

```
AV:N / AC:L / PR:N / UI:R / S:U / C:L / I:L / A:N
```

**CVSS Score:** 5.4

**Описание:**
Идентификатор сессии передаётся через URL, что может привести к его утечке через логи, историю браузера и Referer-заголовки.

**Сетевая доступность:**
Доступна в пользовательских сессиях.

**Ценность актива:**
Учётные записи пользователей и активные сессии.

**Сложность эксплуатации:**
Средняя.

**Потенциальный ущерб:**

* захват пользовательских сессий;
* несанкционированный доступ.

**Приоритет устранения:**  Высокий

**Краткосрочные (компенсирующие) меры:**

* сократить срок жизни пользовательских сессий;

* включить принудительную смену session ID после аутентификации;

* ограничить доступ к чувствительным функциям.

**Долгосрочные (устраняющие) меры:**

* полностью исключить передачу session ID через URL;

* использовать cookies с флагами HttpOnly, Secure, SameSite;

* внедрить централизованное управление сессиями.


### 4. Cross-Domain Misconfiguration (CORS)

**Тип:**  Истинная уязвимость
**Критичность:** Medium

**CVSS 3.1:**

```
AV:N / AC:L / PR:N / UI:R / S:U / C:L / I:N / A:N
```

**CVSS Score:** 4.3

**Описание:**
Неверная настройка CORS позволяет внешним доменам обращаться к ресурсам приложения.

**Сетевая доступность:**
Интернет / локальная сеть.

**Ценность актива:**
API и пользовательские данные.

**Сложность эксплуатации:**
Средняя.

**Потенциальный ущерб:**

* утечка данных;
* проведение CSRF-атак.

**Приоритет устранения:**  Средний

**Краткосрочные (компенсирующие) меры:**

* временно ограничить список разрешённых доменов;

* отключить wildcard (*) в заголовке Access-Control-Allow-Origin.

**Долгосрочные (устраняющие) меры:**

* настроить строгую CORS-политику для каждого API;

* запретить передачу cookies при междоменном доступе;

* регулярно пересматривать CORS-настройки.

### 5. Missing Anti-clickjacking Header

**Тип:**  Истинная уязвимость
**Критичность:** Medium

**CVSS 3.1:**

```
AV:N / AC:L / PR:N / UI:R / S:U / C:L / I:L / A:N
```

**CVSS Score:** 5.4

**Описание:**
Отсутствует заголовок `X-Frame-Options`, что делает возможной атаку clickjacking.

**Приоритет устранения:**  Средний

**Краткосрочные (компенсирующие) меры:**

* добавить заголовок X-Frame-Options: SAMEORIGIN;

* ограничить встраивание страниц в iframe.

**Долгосрочные (устраняющие) меры:**

* использовать директиву frame-ancestors в CSP;

* протестировать интерфейс на устойчивость к clickjacking.

### 6. Timestamp Disclosure (Unix)

**Тип:**  Информационное сообщение
**Критичность:** Low

**Описание:**
Приложение раскрывает Unix-временные метки.

**Оценка:**
Не представляет прямой угрозы, может использоваться только в цепочках атак.

**Приоритет устранения:**  Низкий

**Краткосрочные (компенсирующие) меры:**

* скрыть временные метки в пользовательских ответах API;

* минимизировать отладочную информацию.

**Долгосрочные (устраняющие) меры:**

* стандартизировать формат ответов API;

*разделить данные для логирования и пользовательские данные.



## Приоритизация устранения уязвимостей

На основании результатов триажа, уровня риска, потенциального ущерба и сложности эксплуатации были расставлены приоритеты устранения уязвимостей от наиболее критичных к наименее значимым.

***Порядок приоритетов***

**1. SQL Injection – SQLite**

**2. Session ID in URL Rewrite**

**3. Content Security Policy (CSP) Header Not Set**

**4. Cross-Domain Misconfiguration (CORS)**

**5. Missing Anti-clickjacking Header**

**6. Timestamp Disclosure (Unix)**

***Обоснование приоритизации***

SQL Injection – SQLite имеет наивысший приоритет, так как позволяет напрямую воздействовать на базу данных приложения. Эксплуатация уязвимости возможна без аутентификации и может привести к утечке, модификации или уничтожению данных, а также к полной компрометации системы

Session ID in URL Rewrite занимает второй приоритет, поскольку утечка идентификаторов сессий позволяет захватывать пользовательские аккаунты и получать несанкционированный доступ без взлома учётных данных

Content Security Policy (CSP) Header Not Set размещена ниже, так как сама по себе не приводит к атаке, но значительно упрощает эксплуатацию XSS-уязвимостей и повышает общий уровень риска клиентских атак

Cross-Domain Misconfiguration (CORS) имеет средний приоритет, так как требует дополнительных условий для эксплуатации, но может привести к утечке данных и проведению CSRF-атак при неверной конфигурации

Missing Anti-clickjacking Header относится к уязвимостям среднего-низкого приоритета, поскольку атака требует активного участия пользователя и не приводит к прямой компрометации данных

Timestamp Disclosure (Unix) имеет наименьший приоритет, так как не представляет прямой угрозы безопасности и может рассматриваться как информационное сообщение, устраняемое по остаточному принципу

---


| Критерий                        | **SAST (Bandit, Fortify)**                                                                                                                              | **DAST (ZAP, Nikto)**                                                                                                                                                |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Обнаруженные SQL-инъекции**   | **1 потенциальная** SQL-инъекция (Bandit B608 - строковая конкатенация SQL, confidence Low). Обнаружена на уровне кода, без подтверждения эксплуатации. | **2 подтверждённые** SQL Injection (ZAP: *SQL Injection – SQLite*, High risk). Эксплуатация подтверждена реальными HTTP-запросами.                                   |
| **Обнаруженные XSS-уязвимости** | **0**. SAST не выявил XSS, т.к. анализ без выполнения кода и контекста шаблонов.                                                                        | **2 XSS**: 1 DOM-based + 1 Reflected (ZAP, High risk). Уязвимости воспроизводимы через браузер.                                                                      |
| **Ложные срабатывания**         | **Выше среднего**: есть находки с Low confidence (SQLi, requests без timeout). Требуется ручная валидация.                                              | **Низкие**: большинство уязвимостей подтверждены ответами сервера . Информационные находки (заголовки) не являются ложными, но низкого приоритета. |
| **Время анализа**               | **Очень быстро** (секунды): анализ ~195 строк кода.                                                                                                     | **Дольше**: Nikto ~14 сек, ZAP - несколько минут (сканирование + атаки).                                                                 |
| **Полнота покрытия**            | **Высокая на уровне кода**: видит hardcoded secrets, debug=True, pickle, subprocess, архитектурные ошибки, даже если код не используется.               | **Ограничена доступными endpoint**: видит только то, что доступно по HTTP и по факту исполняется. Не видит внутреннюю логику.                    |
| **Простота использования**      | **Средняя**: нужно уметь интерпретировать отчёты и код (CWE, confidence, false positives).                                                              | **Высокая**: отчёты наглядные, легко демонстрировать уязвимость.                                                                                |


# Ответы на контрольные вопросы

**1. В чем принципиальное отличие SAST от DAST?**

**SAST (Static Application Security Testing)** анализирует исходный код или бинарные файлы приложения без его запуска.
**DAST (Dynamic Application Security Testing)** анализирует работающее приложение путём отправки запросов и анализа ответов.



**2. Какие типы уязвимостей лучше обнаруживает SAST?**

SAST наиболее эффективно обнаруживает:

* SQL-инъекции на уровне кода;
* XSS, связанные с ошибками экранирования;
* ошибки аутентификации и авторизации;
* использование небезопасных функций и API;
* утечки чувствительных данных в исходном коде.



**3. Какие типы уязвимостей лучше обнаруживает DAST?**

DAST лучше выявляет:

* SQL Injection и XSS при обработке HTTP-запросов;
* ошибки конфигурации (CORS, CSP, security headers);
* проблемы управления сессиями;
* уязвимости бизнес-логики;
* ошибки, зависящие от окружения и конфигурации сервера.


**4. Почему важно использовать оба метода в процессе разработки?**

SAST и DAST дополняют друг друга. SAST позволяет выявлять уязвимости на ранних этапах разработки, а DAST демонстрирует, как эти уязвимости проявляются в работающем приложении. Использование обоих методов обеспечивает более полное покрытие безопасности.


**5. Какие ограничения имеют каждый из методов?**

*Ограничения SAST:*

* не учитывает реальные настройки окружения;
* возможны ложные срабатывания;
* не выявляет ошибки логики выполнения.

*Ограничения DAST:*

* не имеет доступа к исходному коду;
* зависит от покрытия тестируемых сценариев;
* сложнее выявляет скрытые логические ошибки.



**6. Что такое AppSec?**

**AppSec (Application Security)** — это совокупность процессов, методов и инструментов, направленных на обеспечение безопасности приложений на всех этапах их жизненного цикла: от проектирования и разработки до эксплуатации.


**7. Что такое триаж уязвимостей и каковы его основные цели?**

Триаж уязвимостей — это процесс анализа результатов сканирования, направленный на подтверждение реальности уязвимостей, оценку их критичности, определение приоритетов устранения и отсеивание ложных срабатываний.

**8. Чем простое сканирование на уязвимости отличается от полноценного процесса триажа?**

Автоматическое сканирование лишь выявляет потенциальные уязвимости, тогда как триаж включает их проверку, оценку риска, анализ влияния на бизнес и принятие решений о дальнейших действиях.

**9. Почему автоматический сканер не может полностью заменить человека в процессе триажа?**

Автоматический сканер не учитывает бизнес-контекст, архитектуру приложения и реальные сценарии эксплуатации. Аналитик компенсирует эти ограничения за счёт опыта, понимания логики приложения и оценки реальных рисков.

**10. Почему важно документировать решение об отложении исправления уязвимости с низким приоритетом?**

Документирование позволяет зафиксировать осознанное управленческое решение, обеспечить прозрачность, упростить аудит и вернуться к оценке риска при изменении условий.

